# 并查集

### 引例

话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。
### 初始化

在江湖上，有非常多的英雄，我们不妨用一个` f `数组来保存每位英雄的掌门
```c++
int X = 10010;
int f[X];
```
在帮派中，有掌门和弟子，那么刚刚开始肯定都是一个人行走江湖，所以在程序初始化的时候，每个人的掌门都是他们自己。
```c++
void init(){
	for(int i = 0;i <= X - 1;i++){
		f[i] = i;
	}
}
```
### 查找根节点

我们在判断两位英雄是否师出同门的时候，要用到查找掌门的函数。这里我们用了记忆化，俗称“压缩路径”。
```c++
int find_f(int x){
	if(x != f[x]){
		return f[x] = find_f(f[x]);//在递归的时候，就直接将遇到的当前帮派的英雄的掌门修改了
	}
	return f[x];//如果找到了掌门，就直接返回掌门编号
}
```
### 合并子集
在确认两位英雄是属于同一个帮派的时候，要把两位英雄的帮派合并，既然师出同门，那两个帮派就是一样的了嘛。

```c++
void join(int x,int y){
	int fx = find_f(x),
    	fy = find_f(y);//找到两位英雄的掌门
	if(fx != fy){
		f[fy] = fx;//合并子集
	}
}
```
### 主函数

```c++
#include <bits/stdc++.h>

using namespace std;
int f[10001];

int find(int x) {
    if (x != f[x]) {
        return f[x] = find(f[x]);
    }
    return f[x];
}

int main() {
    int N, M;
    cin >> N >> M;

    for (int i = 1; i <= N; i++) {
        f[i] = i;
    }

    for (int i = 1; i <= M; i++) {
        int z, x, y;
        cin >> z >> x >> y;
        if (z == 1) {
            int a = find(x);
            int b = find(y);
            if (a != b) {
                f[a] = b;
            }
        } else {
            int a = find(x);
            int b = find(y);
            if (a == b) {
                cout << "Y" << endl;
            } else {
                cout << "N" << endl;
            }
        }
    }
    return 0;
}

```

