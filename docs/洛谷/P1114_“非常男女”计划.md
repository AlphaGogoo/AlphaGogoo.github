#  P1114 “非常男女”计划

## 题目描述

近来，初一年的`XXX`小朋友致力于研究班上同学的配对问题（别想太多，仅是舞伴），通过各种推理和实验，他掌握了大量的实战经验。例如，据他观察，身高相近的人似乎比较合得来。

万圣节来临之际，`XXX`准备在学校策划一次大型的“非常男女”配对活动。对于这次活动的参与者` XXX`有自己独特的选择方式。他希望能选择男女人数相等且身高都很接近的一些人。这种选择方式实现起来很简单。他让学校的所有人按照身高排成一排，然后从中选出连续的若干个人，使得这些人中男女人数相等。为了使活动更热闹，`XXX`当然希望他能选出的人越多越好。请编写程序告诉他，他最多可以选出多少人来。

## 输入格式

第一行有一个正整数 $n$ ，代表学校的人数。  $n$ ≤ $100000$ 

第二行有 $n$ 个用空格隔开的数，这些数只能是 $0$ 或 $1$ ，其中， $0$ 代表一个女生， $1$ 代表一个男生

## 输出格式

输出一个非负整数。这个数表示在输入数据中最长的一段男女人数相等的子序列长度。

如果不存在男女人数相等的子序列，请输出 $0$ 。

## 输入输出样例

**输入**

```
9
0 1 0 0 0 1 1 0 0
```

**输出**

```
6
```

## 题目链接

[P​1114 “非常男女”计划 ](https://www.luogu.com.cn/problem/P1114)

## 题解

为了简化思考，我们把 $0$ 变成 $-1$ 来看，那么男生代表 $1$ ，女生代表 $-1$ 。显然，当一个区间男女各一半时，这个区间的和为 $0$ 。这样，这个题就变成了区间和的问题。

想到区间和自然想到树状数组，树状数组的详细讲解可参考[树状数组](./docs/常用数据结构/树状数组.md)

我们可以遍历数组中的每一对元素，查询出区间和为 $0$ 的最长的序列的长度。

直接上代码：

```c++
#include <bits/stdc++.h>

using namespace std;

int C[101000];

int lowbit(int x) {
    return x & (-x);
}

//A[x]加了一个y
void update(int x, int y, int n) {
    for (int i = x; i <= n; i += lowbit(i)) {
        C[i] += y;
    }
}

//区间查询
int getsum(int x) {
    int ans = 0;
    for (int i = x; i > 0; i -= lowbit(i)) {
        ans += C[i];
    }
    return ans;
}

int main() {
    int n, x;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> x;
        x > 0 ? update(i, x, n) : update(i, -1, n);
    }
    int max = 0;

    for(int i = 1; i <= n; i++){
        for(int j = i+1; j <= n; j++){
            if( getsum(j) - getsum(i-1) == 0 ){
                if( j - i + 1 > max ){
                    max = j - i + 1;
                }
            }
        }
    }
    cout << max;
    return 0;
}
```

当然，这种算法会出现超时，接下来进行优化。

**优化①**

回过来想想，这个题没有对数组元素进行修改，只有第一次赋值，所以区间和完全可以在赋值的时候直接存到数组里，没必要用树状数组。

**优化②**

假设我们已经求出了一个 $max$ ，我们下次就没必要让 $j$ 初始化为 $i$ + $1$ ，因为如果 $max$ > $0$ ，那么当 $j$ < $i$ + $1$ + $max$ 时，[ $i$ , $j$ ]区间的长度必然小于 $max$ ，所以可以直接把 $j$ 初始化为 $i$ + $1$ + $max$ 。

于是代码出来了：

```c++
#include <bits/stdc++.h>

using namespace std;

int C[101000];

int main() {
    int n, x;
    cin >> n;

    for (int i = 1; i <= n; i++) {
        cin >> x;
        //把0换成-1
        x > 0 ? C[i] = C[i-1] + 1 : C[i] = C[i-1] - 1;
    }
    int max = 0;

    for (int i = 1; i < n; i++) {
        for (int j = i + max; j <= n; j++) {
            //人数必然是偶数
            if ( C[j] == C[i-1]) {
                max = j - i + 1;
            }
        }
    }
    cout << max;
    return 0;
}
```

<div align=right>
    2021年2月4日
</div>

