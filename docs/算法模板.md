## 树状数组

```cpp
int origin[N]; //原本数组，下标从1开始
int bit[N]; //树状数组，下标从1开始

int lowbit(int x){
    return x & (-x);
}

void update(int i, int x) {
    //注意这里是大于等于号
    while( i <= n ){
        bit[i] += x;
        i += lowbit(i);
    }
}

int getSum(int i){
    int sum = 0;
    //注意这里是大于号
    while( i > 0 ) {
        sum += bit[i];
        i -= lowbit(i);
    }
    return sum;
}
```

## 线段树

```cpp
#include <bits/stdc++.h>

using namespace std;
const long long N = 1e6 + 7;

typedef long long ll;
struct node {
    long long l, r, sum, add, mul;
} tree[N];

//快读
template<typename T>
void read(T &x) {
    x = 0;
    char ch = (char) getchar();
    ll f = 1;
    if (!isdigit(ch)) {
        if (ch == '-') f = -1;
        ch = (char) getchar();
    }
    while (isdigit(ch)) {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = (char) getchar();
    }
    x *= f;
}

long long init[N]; //存放初始值，下标从1开始
long long n, m, mod;

//建树
void build(long long i, long long l, long long r) {
    tree[i].add = 0;
    tree[i].mul = 1;
    tree[i].l = l;
    tree[i].r = r;
    if (l == r) {
        tree[i].sum = init[l] % mod;
        return;
    }
    long long mid = (l + r) / 2;
    build(2 * i, l, mid);
    build(2 * i + 1, mid + 1, r);
    tree[i].sum = (tree[2 * i].sum + tree[2 * i + 1].sum) % mod;
}

inline void push_down(long long i) {
    tree[2 * i].sum = (tree[i].mul * tree[i * 2].sum + ((tree[i * 2].r - tree[2 * i].l + 1) * tree[i].add) % mod) % mod;
    tree[2 * i + 1].sum = (tree[i].mul * tree[i * 2 + 1].sum + ((tree[i * 2 + 1].r - tree[2 * i + 1].l + 1) * tree[i].add) % mod) % mod;

    tree[i * 2].mul = (tree[2 * i].mul * tree[i].mul) % mod;
    tree[i * 2 + 1].mul = (tree[2 * i + 1].mul * tree[i].mul) % mod;

    tree[i * 2].add = (tree[2 * i].add * tree[i].mul + tree[i].add) % mod;
    tree[i * 2 + 1].add = (tree[2 * i + 1].add * tree[i].mul + tree[i].add) % mod;

    tree[i].mul = 1;
    tree[i].add = 0;
}

//区间[l,r]所有元素各加上k
inline void add(long long i, long long l, long long r, long long k) {
    if (tree[i].l >= l && tree[i].r <= r) {
        tree[i].sum = (tree[i].sum + k * (tree[i].r - tree[i].l + 1)) % mod;
        tree[i].add = (tree[i].add + k) % mod;
        return;
    }
    push_down(i);
    if (tree[i * 2].r >= l)
        add(i * 2, l, r, k);
    if (tree[i * 2 + 1].l <= r)
        add(i * 2 + 1, l, r, k);
    tree[i].sum = (tree[i * 2].sum + tree[i * 2 + 1].sum) % mod;
}


//区间 乘
inline void mult(long long i, long long l, long long r, long long k) {
    if (tree[i].l >= l && tree[i].r <= r) {
        tree[i].mul = (tree[i].mul * k) % mod;
        tree[i].add = (tree[i].add * k) % mod;
        tree[i].sum = (tree[i].sum * k) % mod;
        return;
    }
    push_down(i);
    if (tree[i * 2].r >= l)
        mult(i * 2, l, r, k);
    if (tree[i * 2 + 1].l <= r)
        mult(i * 2 + 1, l, r, k);
    tree[i].sum = (tree[i * 2].sum + tree[i * 2 + 1].sum) % mod;
}


//查询
inline long long search(long long i, long long l, long long r) {
    if (tree[i].l >= l && tree[i].r <= r) {
        return tree[i].sum;
    }
    push_down(i);
    long long s = 0;
    if (tree[i * 2].r >= l)
        s = (s + search(i * 2, l, r)) % mod;
    if (tree[i * 2 + 1].l <= r)
        s = (s + search(i * 2 + 1, l, r)) % mod;
    return s;
}


int main() {
    read(n), read(m), read(mod);
    long long flag, cn, cm, cw;
    for (int i = 1; i <= n; ++i)
        read(init[i]);
    build(1, 1, n);
    for (int i = 1; i <= m; ++i) {
        read(flag);
        if (flag == 1) {
            read(cn), read(cm), read(cw);
            mult(1, cn, cm, cw);
        } else if (flag == 2) {
            read(cn), read(cm), read(cw);
            add(1, cn, cm, cw);
        } else {
            read(cn), read(cm);
            cout << search(1, cn, cm) << endl;
        }
    }
}

```

