## [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

给定一个字符串 `s` 和一个字符串 `t` ，计算在 `s` 的子序列中 `t` 出现的个数。

字符串的一个 **子序列** 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，`"ACE"` 是 `"ABCDE"` 的一个子序列，而 `"AEC"` 不是）

题目数据保证答案符合 32 位带符号整数范围。

 

**示例 1：**

```c++
输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
(上箭头符号 ^ 表示选取的字母)
rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^
```

**示例 2：**

```c++
输入：s = "babgbag", t = "bag"
输出：5
解释：
如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
(上箭头符号 ^ 表示选取的字母)
babgbag
^^ ^
babgbag
^^    ^
babgbag
^    ^^
babgbag
  ^  ^^
babgbag
    ^^^
```

 

**提示：**

- `0 <= s.length, t.length <= 1000`
- `s` 和 `t` 由英文字母组成

### 题解

**1、确定`dp`​数组（dp table）以及下标的含义**
`dp[i][j]`：以`i-1`为结尾的`s`子序列中出现以`j-1`为结尾的t的个数为`dp[i][j]`。

**2、确定递推公式**
这一类问题，基本是要分析两种情况

- `s[i - 1]` 与 `t[j - 1]`相等

  - 当`s[i - 1]` 与 `t[j - 1]`相等时，`dp[i][j]`可以有两部分组成。

    一部分是用`s[i - 1]`来匹配，那么个数为`dp[i - 1][j - 1]`。

    一部分是不用`s[i - 1]`来匹配，个数为`dp[i - 1][j]`。

    这里可能有同学不明白了，为什么还要考虑 不用`s[i - 1]`来匹配，都相同了指定要匹配啊。

    例如： $s:bagg$ 和 $t:bag$ ，`s[3]` 和` t[2]`是相同的，但是`s`也可以不用`s[3]`来匹配，即`s[0]s[1]s[2]`组成的$bag$。

    当然也可以用`s[3]`来匹配，即：`s[0]s[1]s[3]`组成的$bag$。

    所以当`s[i - 1]` 与 `t[j - 1]`相等时，`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`;

- `s[i - 1]` 与 `t[j - 1]` 不相等

  - 当`s[i - 1]` 与 `t[j - 1]`不相等时，`dp[i][j]`只有一部分组成，不用`s[i - 1]`来匹配，即：`dp[i - 1][j]`

    所以递推公式为：`dp[i][j] = dp[i - 1][j]`;

**3、`dp`数组如何初始化**

从递推公式`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`; 和 `dp[i][j] = dp[i - 1][j]`中可以看出`dp[i][0]` 和`dp[0][j]`是一定要初始化的。

每次当初始化的时候，都要回顾一下`dp[i][j]`的定义，不要凭感觉初始化。

`dp[i][0]`表示什么呢？

`dp[i][0]` 以`i-1`为结尾的 $s$ 可以随便删除元素，出现空字符串的个数。

那么`dp[i][0]`一定都是$1$，因为也就是把以`i-1`为结尾的 $s$，删除所有元素，出现空字符串的个数就是 $1$。

再来看`dp[0][j]`，`dp[0][j]`：空字符串 $s$ 可以随便删除元素，出现以`j-1`为结尾的字符串t的个数。

那么`dp[0][j]`一定都是 $0$，$s $ 如论如何也变成不了 $t$。

最后就要看一个特殊位置了，即：`dp[0][0]` 应该是多少。

`dp[0][0]`应该是$1$，空字符串$s$，可以删除$0$个元素，变成空字符串$t$。

初始化分析完毕，代码如下：

```cpp
vector<vector<long long>> dp(s.size() + 1, vector<long long>(t.size() + 1));
for (int i = 0; i <= s.size(); i++) 
    dp[i][0] = 1;
for (int j = 1; j <= t.size(); j++) 
    dp[0][j] = 0; // 其实这行代码可以和dp数组初始化的时候放在一起，但我为了凸显初始化的逻辑，所以还是加上了。
```

**4、确定遍历顺序**

从递推公式`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`; 和 `dp[i][j] = dp[i - 1][j]`; 中可以看出`dp[i][j]`都是根据左上方和正上方推出来的。

所以遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。

**5、代码如下：**

```cpp
for (int i = 1; i <= s.size(); i++) {
    for (int j = 1; j <= t.size(); j++) {
        if (s[i - 1] == t[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
        } else {
            dp[i][j] = dp[i - 1][j];
        }
    }
}
```

**完整代码如下：**

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        int m = s.size(), n = t.size();
        vector<vector<long long> >dp( m + 1, vector<long long> (n + 1) );
        for(int i = 1; i <= n; i++)
            dp[0][i] = 0;
        for(int i = 0; i <= m; i++)
            dp[i][0] = 1;
        
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if( s[i-1] == t[j-1] ){
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[m][n];
    }
};
```

<div align=right>
    2021年3月17日
</div>

