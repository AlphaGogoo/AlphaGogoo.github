## 实验一 搜索

### 1、实验内容

- 求解罗马尼亚度假问题，找到从`Arad`到`Bucharest`的一条路径

- 实现两种搜索算法求解该问题

  - 一种无信息搜索算法：任选一种
  - 有信息搜索算法：$A*$搜索

  \* 地图信息可用邻接矩阵或邻接表等存储

  <div align=center >
      <img width="700" src = ../../imgs/其他/城市网络.png>
  </div>
  
  
  

<div align=center>
    图1 城市网络图
</div>


<div align=center >
    <img width = "700" src = ../../imgs/其他/直线距离.png>
</div>


<div align=center>
    图2 每个城市到Bucharest的直线距离
</div>

### 2、编程语言

`C++`

### 3、算法

- $dijkstra$算法
- $A*$算法

### 4、思路

- **无信息搜索方法**

  图的存储结构采用邻接矩阵。

  首先将城市网络图输入到边表中$($为了方便，直接将边的信息写入构建的边表中$)$。

  然后利用$dijkstra$算法，直接对问题进行求解。

  ​	$dijkstra$函数中，`prev[]`数组存放节点 $i$ 的前驱顶点

  ​	`dist[]` 数组存放 $start$ 节点到节点 $i$ 的最短路径长度

  ​	算法中，首先将 $start$ 节点加入最短路径中，然后查找其邻接点，找到离$start$最近的顶点	$k$，将其加入到最短路径中。然后利用刚纳入最短路径的顶点 $k$ 更新未纳入最短路径的顶点的最短路径以及前驱结点。

  ​	重复`顶点数-1`次上述操作，结束算法。

  根据`prev[]`数组中的信息，利用递归，从前到后打印路径。

- **有信息的搜索方法**

  题目中给出的信息为每个节点到目标节点的直线距离，我们采用$A*$算法求解。

  给定方程：$F(i) = G(i) + H(i)$， 其中，$G(i)$ = 从起点 $start$ 移动到顶点i的移动代价,$H(i)$ = 从顶点 $i$ 移动到终点 $target$ 的估算成本。

  $AStar$算法中，$pq$ 为优先队列，用来存放$F[i]$ 的最小值

  首先，我们将$start$顶点加入优先队列。

  然后，每次从优先队列中取出一个顶点$s$，将其加入最短路径序列中，遍历其邻接点，找到所有临接点中$F[i]$最下的顶点$k$，将$s - k$的距离加入最短路径长度中，将$k$加入优先队列，重复操作，当最后找到的$F[i]$最小的临接点为$target$顶点时，结束算法。

  

### 5、程序运行结果

<div align=center width="500">
    <img src = ../../imgs/其他/运行结果.png>
</div>

### 6、算法分析

虽然$dijkstra$算法和$A*$算法都能得到正确结果，但是相比来说，$A*$算法利用了提供的信息，能够计算出当前顶点到目标顶点的期望代价，是一种启发式的算法，少了很多不必要的搜索。$dijkstra$算法实质是广度优先搜索，是一种发散式的搜索，时间复杂度和空间复杂度较高

另外，$dijkstra$算法可以计算一个点到所有顶点的最短路径，而$A*$算法只能计算一个点到另一个点的最短路径，所以，当目标点很多时，$A*$算法会带入大量重复数据，所以如果不要求获得具体路径而只比较路径长度时，$dijkstra$算法更优。

<div align=right>
    2021年3月21日
</div>

